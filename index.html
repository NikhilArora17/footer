<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>B1B5C0 Smoke Footer â€” Auto Height (All Screens)</title>
<style>
  :root{
    /* MOTION */
    --speed: 0.045;
    --swirl: 0.10;

    /* LOOK */
    --detail: 1.5;
    --soft: 2.4;
    --alpha: 0.92;

    /* COLOR */
    --colorA: #E6E8EE;
    --colorB: #B1B5C0;
  }

  /* Keep page clean in an iframe */
  html,body{
    margin:0;
    height:100%;
    background:transparent;
    overflow:hidden; /* avoid accidental scroll on tiny overflows */
  }

  /* Wrapper: fills parent width, height = safe viewport height
     Order: older browsers -> new units -> JS var fallback */
  #wrap{
    width: 100%;                /* <-- safer than 100vw inside Wix iframes */
    height: 100vh;              /* legacy fallback */
    height: 100dvh;             /* modern exact viewport height */
    height: 100svh;             /* iOS/Android toolbar-aware */
    height: calc(var(--vh, 1vh) * 100); /* JS fallback for mobile 100vh bug */
  }

  /* Canvas fills wrapper exactly */
  #fx{
    display:block;
    width:100%;
    height:100%;
    pointer-events:none;
  }
</style>
</head>
<body>

<div id="wrap">
  <canvas id="fx"></canvas>
</div>

<script>
/* ----- Viewport height fix for iOS/Android toolbars ----- */
function setVH(){
  // 1vh = 1% of the *visible* viewport height
  const vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
}
setVH();
addEventListener('resize', setVH);
addEventListener('orientationchange', setVH);

const canvas = document.getElementById('fx');
const host   = document.getElementById('wrap');
const gl = canvas.getContext('webgl', { alpha:true, antialias:true, premultipliedAlpha:true });
if(!gl){ throw new Error('WebGL not supported'); }

/* ----- Shader (unchanged) ----- */
const VSH = `
attribute vec2 p; varying vec2 uv;
void main(){ uv = p*0.5+0.5; gl_Position = vec4(p,0.,1.); }
`;
const FSH = `
precision highp float; varying vec2 uv;
uniform vec2 uRes; uniform float uT, uSpeed, uSwirl, uDetail, uSoft, uAlpha;
uniform vec3 uA, uB;
vec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}
vec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}
vec4 permute(vec4 x){return mod289(((x*34.)+1.)*x);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
float snoise(vec3 v){
  const vec2 C=vec2(1./6.,1./3.); const vec4 D=vec4(0.,.5,1.,2.);
  vec3 i=floor(v+dot(v,C.yyy));
  vec3 x0=v-i+dot(i,C.xxx);
  vec3 g=step(x0.yzx,x0.xyz), l=1.-g;
  vec3 i1=min(g.xyz,l.zxy), i2=max(g.xyz,l.zxy);
  vec3 x1=x0-i1+C.xxx, x2=x0-i2+2.*C.xxx, x3=x0-1.+3.*C.xxx;
  i=mod289(i);
  vec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+i.y+vec4(0.,i1.y,i2.y,1.))+i.x+vec4(0.,i1.x,i2.x,1.));
  float n_=0.142857142857; vec3 ns=n_*D.wyz-D.xzx;
  vec4 j=p-49.*floor(p*ns.z*ns.z);
  vec4 x_=floor(j*ns.z), y_=floor(j-7.*x_);
  vec4 x=x_*ns.x+ns.yyyy, y=y_*ns.x+ns.yyyy, h=1.-abs(x)-abs(y);
  vec4 b0=vec4(x.xy,y.xy), b1=vec4(x.zw,y.zw);
  vec4 s0=floor(b0)*2.+1., s1=floor(b1)*2.+1., sh=-step(h,vec4(0.));
  vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy, a1=b1.xzyw+s1.xzyw*sh.zzww;
  vec3 p0=vec3(a0.xy,h.x), p1=vec3(a0.zw,h.y), p2=vec3(a1.xy,h.z), p3=vec3(a1.zw,h.w);
  vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
  p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;
  vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.); m*=m;
  return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
}
float fbm(vec3 p){
  float f=0., a=.5;
  for(int i=0;i<5;i++){ f+=a*snoise(p); p=p*2.02+vec3(.3,.6,.2); a*=.5; }
  return f*0.5+0.5;
}
void main(){
  float aspect = uRes.x/uRes.y;
  vec2 suv = vec2(uv.x*aspect, uv.y);
  vec3 base = vec3(suv.x*uDetail, (suv.y - uT*uSpeed)*uDetail, uT*uSwirl);
  float w1 = fbm(base);
  float w2 = fbm(base + vec3(0.7,0.5,0.3));
  float n  = fbm(base + vec3(w1-0.5, w2-0.5, 0.0)*0.8);
  float density = smoothstep(0.35, 0.90, n);
  float envelope = pow(1.0 - uv.y, uSoft);
  float a = clamp(density * envelope * uAlpha, 0.0, 1.0);
  vec3 col = mix(uB, uA, density*0.95);
  float d = fract(sin(dot(uv*uRes, vec2(12.9898,78.233))) * 43758.5453);
  col += (d-0.5)*0.0035;
  gl_FragColor = vec4(col, a);
}
`;

function compile(t,src){
  const s=gl.createShader(t); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
  return s;
}
const prog=gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, VSH));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FSH));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

const buf=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
const loc=gl.getAttribLocation(prog,'p'); gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

const Ures=gl.getUniformLocation(prog,'uRes');
const Ut=gl.getUniformLocation(prog,'uT');
const Uspeed=gl.getUniformLocation(prog,'uSpeed');
const Uswirl=gl.getUniformLocation(prog,'uSwirl');
const Udet=gl.getUniformLocation(prog,'uDetail');
const Usoft=gl.getUniformLocation(prog,'uSoft');
const Ualpha=gl.getUniformLocation(prog,'uAlpha');
const UA=gl.getUniformLocation(prog,'uA');
const UB=gl.getUniformLocation(prog,'uB');

const css=getComputedStyle(document.documentElement);
const num=(name,def)=>{ const v=parseFloat(css.getPropertyValue(name)); return Number.isFinite(v)?v:def; };
const parseColor = name => {
  let c = css.getPropertyValue(name).trim() || '#B1B5C0';
  const ctx = document.createElement('canvas').getContext('2d'); ctx.fillStyle=c;
  const m = ctx.fillStyle.match(/\d+(\.\d+)?/g).map(Number);
  return new Float32Array([m[0]/255, m[1]/255, m[2]/255]);
};

gl.uniform1f(Uspeed, num('--speed',0.045));
gl.uniform1f(Uswirl, num('--swirl',0.10));
gl.uniform1f(Udet,   num('--detail',1.5));
gl.uniform1f(Usoft,  num('--soft',2.4));
gl.uniform1f(Ualpha, num('--alpha',0.92));
gl.uniform3fv(UA, parseColor('--colorA'));
gl.uniform3fv(UB, parseColor('--colorB'));

/* ----- DPR-aware resize to wrapper ----- */
function resize(){
  const w = host.clientWidth;
  const h = host.clientHeight;
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width  = Math.max(2, Math.floor(w * DPR));
  canvas.height = Math.max(2, Math.floor(h * DPR));
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.uniform2f(Ures, canvas.width, canvas.height);
}
new ResizeObserver(resize).observe(host);
addEventListener('resize', resize);
addEventListener('orientationchange', resize);

let t0=performance.now();
function draw(t){ gl.uniform1f(Ut,(t-t0)/1000); gl.drawArrays(gl.TRIANGLE_STRIP,0,4); requestAnimationFrame(draw); }
resize(); requestAnimationFrame(draw);

/* Reduced motion support (unchanged) */
const mq=matchMedia('(prefers-reduced-motion: reduce)');
mq.addEventListener?.('change',()=>{
  gl.uniform1f(Uspeed, mq.matches?0.0:num('--speed',0.045));
  gl.uniform1f(Uswirl, mq.matches?0.0:num('--swirl',0.10));
});
</script>
</body>
</html>
