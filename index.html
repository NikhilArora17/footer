<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Soft Smoke Footer — Transparent</title>
<style>
  :root{
    /* ---- QUICK TWEAKS ---- */
    --height: 420px;   /* iframe/canvas height */
    --speed: 0.15;    /* upward drift speed (0.02–0.09) */
    --swirl: 0.15;     /* internal motion (0.04–0.20) */
    --detail: 1.5;     /* smoke detail scale (1.2–2.4; lower = broader) */
    --soft: 1.3;       /* how gently it dies as it rises (1.6–3.0) */
    --alpha: 0.58;     /* overall opacity */

    /* Color mood (warm). For charcoal, use greys (examples below). */
    --colorA: #B1B5C0; /* light through smoke */
    --colorB: #B1B5C0; /* base */
    /*
    Charcoal:
    --colorA:#1f232a; --colorB:#0f1318;
    Cool:
    --colorA:#5fd3ff; --colorB:#0c1620;
    */
  }
  html,body{margin:0;height:100%;background:transparent;}
  #fx{display:block;width:100%;height:var(--height);pointer-events:none;}
</style>
</head>
<body>
<canvas id="fx"></canvas>

<script>
/* ---------- WebGL smoke (no libs) ---------- */
const c = document.getElementById('fx');
const gl = c.getContext('webgl', { alpha:true, antialias:true, premultipliedAlpha:true });
if(!gl){ document.body.style.background='transparent'; throw new Error('WebGL not available'); }

const DPR = Math.min(devicePixelRatio||1,2);
const VSH = `
attribute vec2 p; varying vec2 uv;
void main(){ uv = p*0.5+0.5; gl_Position=vec4(p,0.,1.); }
`;
const FSH = `
precision highp float; varying vec2 uv;
uniform vec2 uRes; uniform float uT, uSpeed, uSwirl, uDetail, uSoft, uAlpha;
uniform vec3 uA, uB;

/* 3D simplex noise + fbm */
vec3 mod289(vec3 x){return x - floor(x*(1./289.))*289.;}
vec4 mod289(vec4 x){return x - floor(x*(1./289.))*289.;}
vec4 permute(vec4 x){return mod289(((x*34.)+1.)*x);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314*r;}
float snoise(vec3 v){
  const vec2 C=vec2(1./6.,1./3.); const vec4 D=vec4(0.,.5,1.,2.);
  vec3 i=floor(v+dot(v,C.yyy));
  vec3 x0=v-i+dot(i,C.xxx);
  vec3 g=step(x0.yzx,x0.xyz), l=1.-g;
  vec3 i1=min(g.xyz,l.zxy), i2=max(g.xyz,l.zxy);
  vec3 x1=x0-i1+C.xxx, x2=x0-i2+2.*C.xxx, x3=x0-1.+3.*C.xxx;
  i=mod289(i);
  vec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+i.y+vec4(0.,i1.y,i2.y,1.))+i.x+vec4(0.,i1.x,i2.x,1.));
  float n_=0.142857142857; vec3 ns=n_*D.wyz-D.xzx;
  vec4 j=p-49.*floor(p*ns.z*ns.z);
  vec4 x_=floor(j*ns.z), y_=floor(j-7.*x_);
  vec4 x=x_*ns.x+ns.yyyy, y=y_*ns.x+ns.yyyy, h=1.-abs(x)-abs(y);
  vec4 b0=vec4(x.xy,y.xy), b1=vec4(x.zw,y.zw);
  vec4 s0=floor(b0)*2.+1., s1=floor(b1)*2.+1., sh=-step(h,vec4(0.));
  vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy, a1=b1.xzyw+s1.xzyw*sh.zzww;
  vec3 p0=vec3(a0.xy,h.x), p1=vec3(a0.zw,h.y), p2=vec3(a1.xy,h.z), p3=vec3(a1.zw,h.w);
  vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
  p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;
  vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);
  m*=m;
  return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
}
float fbm(vec3 p){
  float f=0., a=.5;
  for(int i=0;i<5;i++){ f+=a*snoise(p); p=p*2.02+vec3(.3,.6,.2); a*=.5; }
  return f*0.5+0.5;
}

void main(){
  float aspect=uRes.x/uRes.y;
  vec2 suv=vec2(uv.x*aspect, uv.y);

  // Upward drift + gentle evolution
  vec3 base = vec3(suv.x*uDetail, (suv.y - uT*uSpeed)*uDetail, uT*uSwirl); // move up

  // Domain-warped fbm for silky smoke
  float w1 = fbm(base);
  float w2 = fbm(base + vec3(0.7,0.5,0.3));
  float n  = fbm(base + vec3(w1-0.5, w2-0.5, 0.0)*0.8);

  // Soft density mapping (no bandy edges)
  float density = smoothstep(0.35, 0.90, n);

  // Heavier at bottom, dies upward
  float envelope = pow(1.0 - uv.y, uSoft); // denser at bottom, dies upward
  float a = clamp(density * envelope * uAlpha, 0.0, 1.0);

  // Light-through-smoke color blend + tiny dither
  vec3 col = mix(uB, uA, density*0.95);
  float d = fract(sin(dot(uv*uRes, vec2(12.9898,78.233))) * 43758.5453);
  col += (d-0.5)*0.004;

  gl_FragColor = vec4(col, a);
}
`;

function shader(type, src){
  const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
  return s;
}
const prog=gl.createProgram();
gl.attachShader(prog, shader(gl.VERTEX_SHADER, VSH));
gl.attachShader(prog, shader(gl.FRAGMENT_SHADER, FSH));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

const buf=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
const loc=gl.getAttribLocation(prog,'p');
gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

const Ures=gl.getUniformLocation(prog,'uRes');
const Ut = gl.getUniformLocation(prog,'uT');
const Uspeed = gl.getUniformLocation(prog,'uSpeed');
const Uswirl = gl.getUniformLocation(prog,'uSwirl');
const Udet = gl.getUniformLocation(prog,'uDetail');
const Usoft= gl.getUniformLocation(prog,'uSoft');
const Ualpha=gl.getUniformLocation(prog,'uAlpha');
const UA = gl.getUniformLocation(prog,'uA');
const UB = gl.getUniformLocation(prog,'uB');

const css=getComputedStyle(document.documentElement);
const num = (n, d)=>{ const v=parseFloat(css.getPropertyValue(n)); return Number.isFinite(v)?v:d; };
const parseColor = n => {
  let c = css.getPropertyValue(n).trim();
  const ctx=document.createElement('canvas').getContext('2d');
  ctx.fillStyle = c||'#ffffff';
  const m = ctx.fillStyle.match(/\d+(\.\d+)?/g).map(Number);
  return new Float32Array([m[0]/255,m[1]/255,m[2]/255]);
};

gl.uniform1f(Uspeed, num('--speed',0.045));
gl.uniform1f(Uswirl, num('--swirl',0.10));
gl.uniform1f(Udet,   num('--detail',1.7));
gl.uniform1f(Usoft,  num('--soft',2.3));
gl.uniform1f(Ualpha, num('--alpha',0.98));
gl.uniform3fv(UA, parseColor('--colorA'));
gl.uniform3fv(UB, parseColor('--colorB'));

function resize(){
  const w=c.clientWidth, h=c.clientHeight;
  c.width=Math.max(2,Math.floor(w*DPR));
  c.height=Math.max(2,Math.floor(h*DPR));
  gl.viewport(0,0,c.width,c.height);
  gl.uniform2f(Ures, c.width, c.height);
}
new ResizeObserver(resize).observe(c);

let t0=performance.now();
function draw(t){
  gl.uniform1f(Ut, (t-t0)/1000);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(draw);
}
resize(); requestAnimationFrame(draw);

/* Reduced motion */
const mq = matchMedia('(prefers-reduced-motion: reduce)');
mq.addEventListener?.('change', ()=> {
  gl.uniform1f(Uspeed, mq.matches?0.0:num('--speed',0.045));
  gl.uniform1f(Uswirl, mq.matches?0.0:num('--swirl',0.10));
});
</script>
</body>
</html>
